name: Reusable Security Scan

on:
  workflow_call:
    inputs:
      app_name:
        description: 'Name of the application being scanned'
        required: true
        type: string
      target_url:
        description: 'URL to scan (for DAST scanning)'
        required: false
        type: string
        default: ''
      scan_type:
        description: 'Type of scan to run (sast, secrets, dast, dependencies, container, iac, license, financial, backend, frontend, or all)'
        required: false
        type: string
        default: 'all'
      notification_email:
        description: 'Email address for notifications'
        required: false
        type: string
        default: ''
      repository_name:
        description: 'Name of the repository being scanned'
        required: false
        type: string
        default: ${{ github.repository }}
      include_financial_compliance:
        description: 'Include financial services compliance checks'
        required: false
        type: boolean
        default: true
      severity_threshold:
        description: 'Minimum severity level to report (low, medium, high, critical)'
        required: false
        type: string
        default: 'medium'
      app_framework:
        description: 'Application framework (vite, nextjs, react, node)'
        required: false
        type: string
        default: 'auto-detect'
      node_version:
        description: 'Node.js version to use'
        required: false
        type: string
        default: '18'
    secrets:
      SNYK_TOKEN:
        description: 'Snyk API token for dependency scanning'
        required: false
      FOSSA_API_KEY:
        description: 'FOSSA API key for license compliance'
        required: false
      SEMGREP_APP_TOKEN:
        description: 'Semgrep App token for enhanced SAST scanning'
        required: false
      SECURITY_EMAIL_WEBHOOK:
        description: 'Webhook URL for security notifications'
        required: false

permissions:
  contents: read
  issues: write
  security-events: write
  actions: read

jobs:
  security-scan:
    runs-on: ubuntu-latest
    name: Security Scan for ${{ inputs.app_name }}
    continue-on-error: true

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Security Scan Header
        run: |
          echo "üõ°Ô∏è Starting Security Scan for ${{ inputs.app_name }}"
          echo "üìã Repository: ${{ inputs.repository_name }}"
          echo "üîç Scan Type: ${{ inputs.scan_type }}"
          echo "üéØ Target URL: ${{ inputs.target_url || 'N/A' }}"
          echo "üìß Notifications: ${{ inputs.notification_email || 'None' }}"
          echo "‚öñÔ∏è Financial Compliance: ${{ inputs.include_financial_compliance }}"
          echo "üö® Severity Threshold: ${{ inputs.severity_threshold }}"
          echo "üöÄ Framework: ${{ inputs.app_framework }}"
          mkdir -p security-results

      - name: Detect Application Framework
        id: framework
        run: |
          FRAMEWORK="${{ inputs.app_framework }}"

          if [ "$FRAMEWORK" = "auto-detect" ]; then
            if [ -f "next.config.js" ] || [ -f "next.config.ts" ] || [ -f "next.config.mjs" ]; then
              FRAMEWORK="nextjs"
            elif [ -f "vite.config.js" ] || [ -f "vite.config.ts" ]; then
              FRAMEWORK="vite"
            elif [ -f "package.json" ]; then
              if grep -q "\"next\":" package.json; then
                FRAMEWORK="nextjs"
              elif grep -q "\"vite\":" package.json; then
                FRAMEWORK="vite"
              else
                FRAMEWORK="react"
              fi
            else
              FRAMEWORK="node"
            fi
          fi

          echo "Detected framework: $FRAMEWORK"
          echo "framework=$FRAMEWORK" >> $GITHUB_OUTPUT

      - name: Set up scan results
        id: scan-results
        run: |
          echo "has_issues=false" >> $GITHUB_OUTPUT
          echo "scan_summary=" >> $GITHUB_OUTPUT
          echo "findings_count=0" >> $GITHUB_OUTPUT

      # Determine what scans to run
      - name: Determine scan configuration
        id: scan-config
        run: |
          SCAN_TYPE="${{ inputs.scan_type }}"

          # Frontend scan = sast,secrets,dependencies,container,dast (includes DAST for web apps)
          if [ "$SCAN_TYPE" = "frontend" ]; then
            echo "run_sast=true" >> $GITHUB_OUTPUT
            echo "run_secrets=true" >> $GITHUB_OUTPUT
            echo "run_dependencies=true" >> $GITHUB_OUTPUT
            echo "run_container=true" >> $GITHUB_OUTPUT
            echo "run_iac=false" >> $GITHUB_OUTPUT
            echo "run_dast=true" >> $GITHUB_OUTPUT
            echo "run_license=true" >> $GITHUB_OUTPUT
            echo "run_financial=true" >> $GITHUB_OUTPUT
          # Backend scan = sast,secrets,dependencies,container,iac
          elif [ "$SCAN_TYPE" = "backend" ]; then
            echo "run_sast=true" >> $GITHUB_OUTPUT
            echo "run_secrets=true" >> $GITHUB_OUTPUT
            echo "run_dependencies=true" >> $GITHUB_OUTPUT
            echo "run_container=true" >> $GITHUB_OUTPUT
            echo "run_iac=true" >> $GITHUB_OUTPUT
            echo "run_dast=false" >> $GITHUB_OUTPUT
            echo "run_license=true" >> $GITHUB_OUTPUT
            echo "run_financial=true" >> $GITHUB_OUTPUT
          elif [ "$SCAN_TYPE" = "all" ]; then
            echo "run_sast=true" >> $GITHUB_OUTPUT
            echo "run_secrets=true" >> $GITHUB_OUTPUT
            echo "run_dependencies=true" >> $GITHUB_OUTPUT
            echo "run_container=true" >> $GITHUB_OUTPUT
            echo "run_iac=true" >> $GITHUB_OUTPUT
            echo "run_dast=true" >> $GITHUB_OUTPUT
            echo "run_license=true" >> $GITHUB_OUTPUT
            echo "run_financial=true" >> $GITHUB_OUTPUT
          else
            # Check individual scan types
            echo "run_sast=$(if [[ "$SCAN_TYPE" == *"sast"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
            echo "run_secrets=$(if [[ "$SCAN_TYPE" == *"secrets"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
            echo "run_dependencies=$(if [[ "$SCAN_TYPE" == *"dependencies"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
            echo "run_container=$(if [[ "$SCAN_TYPE" == *"container"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
            echo "run_iac=$(if [[ "$SCAN_TYPE" == *"iac"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
            echo "run_dast=$(if [[ "$SCAN_TYPE" == *"dast"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
            echo "run_license=$(if [[ "$SCAN_TYPE" == *"license"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
            echo "run_financial=$(if [[ "$SCAN_TYPE" == *"financial"* ]]; then echo true; else echo false; fi)" >> $GITHUB_OUTPUT
          fi

      - name: Setup Node.js
        if: steps.scan-config.outputs.run_dependencies == 'true' || steps.scan-config.outputs.run_sast == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: 'npm'

      - name: Install dependencies for scanning
        if: steps.scan-config.outputs.run_dependencies == 'true' || steps.scan-config.outputs.run_sast == 'true'
        continue-on-error: true
        run: |
          if [ -f "package-lock.json" ]; then
            if ! npm ci --legacy-peer-deps; then
              echo "npm ci failed, trying alternative approach..."
              rm -f package-lock.json
              npm install --legacy-peer-deps
            fi
          elif [ -f "package.json" ]; then
            npm install --legacy-peer-deps
          fi

      # Enhanced Secrets Detection with GitLeaks
      - name: "üîê Secrets Detection with GitLeaks"
        if: steps.scan-config.outputs.run_secrets == 'true'
        continue-on-error: true
        run: |
          echo "üîç Running GitLeaks secrets scan (Free Version)"

          # Install GitLeaks (Free version)
          wget -q https://github.com/gitleaks/gitleaks/releases/latest/download/gitleaks_8.18.4_linux_x64.tar.gz
          tar -xzf gitleaks_8.18.4_linux_x64.tar.gz
          chmod +x gitleaks

          # Run GitLeaks scan (works without license for basic scanning)
          ./gitleaks detect --source . --report-format json --report-path security-results/gitleaks-report.json --verbose || echo "GitLeaks completed with findings"

          # Process results
          if [ -f "security-results/gitleaks-report.json" ]; then
            SECRETS_COUNT=$(jq length security-results/gitleaks-report.json 2>/dev/null || echo "0")
            echo "üìã GitLeaks found $SECRETS_COUNT potential secrets"
            echo "secrets_found=$SECRETS_COUNT" >> $GITHUB_OUTPUT

            if [ "$SECRETS_COUNT" -gt 0 ]; then
              echo "üö® SECURITY ALERT: Potential secrets detected!"
              echo "has_issues=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è GitLeaks scan failed, trying alternative secret detection..."

            # Fallback: Simple grep-based secret detection
            echo "üîç Running fallback secret detection with grep patterns..."

            # Simple secret detection using basic patterns
            GREP_FINDINGS=0

            # Check for API keys
            if grep -r -i "api[_-]key.*[:=]" . --exclude-dir=node_modules --exclude-dir=.git --exclude="*.log" --exclude="*.md" | grep -v "TODO\|FIXME\|example" >/dev/null 2>&1; then
              GREP_FINDINGS=$((GREP_FINDINGS + 1))
            fi

            # Check for access tokens
            if grep -r -i "access[_-]token.*[:=]" . --exclude-dir=node_modules --exclude-dir=.git --exclude="*.log" --exclude="*.md" | grep -v "TODO\|FIXME\|example" >/dev/null 2>&1; then
              GREP_FINDINGS=$((GREP_FINDINGS + 1))
            fi

            # Check for secrets
            if grep -r -i "secret.*[:=]" . --exclude-dir=node_modules --exclude-dir=.git --exclude="*.log" --exclude="*.md" | grep -v "TODO\|FIXME\|example" >/dev/null 2>&1; then
              GREP_FINDINGS=$((GREP_FINDINGS + 1))
            fi

            # Check for passwords
            if grep -r -i "password.*[:=]" . --exclude-dir=node_modules --exclude-dir=.git --exclude="*.log" --exclude="*.md" | grep -v "TODO\|FIXME\|example" >/dev/null 2>&1; then
              GREP_FINDINGS=$((GREP_FINDINGS + 1))
            fi

            if [ "$GREP_FINDINGS" -gt 0 ]; then
              echo "üö® SECURITY ALERT: $GREP_FINDINGS potential secrets detected by fallback scan!"
              echo "has_issues=true" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ No secrets detected by fallback scan"
            fi
          fi

      # Free SAST Scanning with Semgrep Community Rules
      - name: "üîç Free SAST Scan with Semgrep Community"
        if: steps.scan-config.outputs.run_sast == 'true'
        continue-on-error: true
        run: |
          echo "üìù Running Semgrep SAST scan (Free Community Rules)"
          pip install semgrep

          # Framework-specific rules (free community rules)
          FRAMEWORK="${{ steps.framework.outputs.framework }}"
          RULES="--config=auto --config=p/security-audit --config=p/owasp-top-ten"

          if [ "$FRAMEWORK" = "nextjs" ]; then
            RULES="$RULES --config=p/react --config=p/typescript"
          elif [ "$FRAMEWORK" = "vite" ] || [ "$FRAMEWORK" = "react" ]; then
            RULES="$RULES --config=p/react --config=p/typescript"
          fi

          # Add financial compliance rules (free alternatives)
          if [ "${{ inputs.include_financial_compliance }}" = "true" ]; then
            RULES="$RULES --config=p/bandit --config=p/nodejs-scan"
          fi

          # Run Semgrep without app token (free tier)
          semgrep $RULES \
            --json \
            --output=security-results/semgrep-results.json \
            . || echo "Semgrep completed with findings"

          # Process results
          if [ -f "security-results/semgrep-results.json" ]; then
            FINDINGS_COUNT=$(jq '.results | length' security-results/semgrep-results.json 2>/dev/null || echo "0")
            echo "üìã Semgrep found $FINDINGS_COUNT security findings"
            echo "semgrep_findings=$FINDINGS_COUNT" >> $GITHUB_OUTPUT

            if [ "$FINDINGS_COUNT" -gt 0 ]; then
              echo "üö® SECURITY ALERT: SAST findings detected!"
              echo "has_issues=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è Semgrep scan failed, continuing with other SAST tools..."
          fi

      # Free SAST Scanning with ESLint Security
      - name: "üîç Free SAST Scan with ESLint Security"
        if: steps.scan-config.outputs.run_sast == 'true'
        continue-on-error: true
        run: |
          echo "üìù Running free SAST scan with ESLint security plugins"

          # Check if we have package.json (Node.js project)
          if [ ! -f "package.json" ]; then
            echo "No package.json found, skipping ESLint security scan"
            exit 0
          fi

          # Install ESLint security plugins
          npm install --no-save eslint@8 @typescript-eslint/eslint-plugin@6 eslint-plugin-security@1 eslint-plugin-react-hooks@4 eslint-plugin-jsx-a11y@6 || echo "Failed to install some ESLint plugins"

          # Create temporary ESLint config for security scanning
          cat > .eslintrc-security.json << 'EOF'
          {
            "env": {
              "browser": true,
              "es2021": true,
              "node": true
            },
            "extends": [
              "eslint:recommended"
            ],
            "plugins": [
              "security",
              "react-hooks",
              "jsx-a11y"
            ],
            "rules": {
              "security/detect-object-injection": "error",
              "security/detect-non-literal-regexp": "error",
              "security/detect-unsafe-regex": "error",
              "security/detect-buffer-noassert": "error",
              "security/detect-child-process": "error",
              "security/detect-disable-mustache-escape": "error",
              "security/detect-eval-with-expression": "error",
              "security/detect-no-csrf-before-method-override": "error",
              "security/detect-non-literal-fs-filename": "error",
              "security/detect-non-literal-require": "error",
              "security/detect-possible-timing-attacks": "error",
              "security/detect-pseudoRandomBytes": "error",
              "react-hooks/rules-of-hooks": "error",
              "react-hooks/exhaustive-deps": "warn",
              "jsx-a11y/alt-text": "error",
              "jsx-a11y/anchor-has-content": "error"
            },
            "parser": "@typescript-eslint/parser",
            "parserOptions": {
              "ecmaVersion": 2021,
              "sourceType": "module",
              "ecmaFeatures": {
                "jsx": true
              }
            }
          }
          EOF

          # Run ESLint security scan
          ESLINT_EXIT_CODE=0
          npx eslint --config .eslintrc-security.json \
            --ext .js,.jsx,.ts,.tsx \
            --format json \
            --output-file security-results/eslint-security-results.json \
            src/ . || ESLINT_EXIT_CODE=$?

          echo "ESLint security scan completed (exit code: $ESLINT_EXIT_CODE)"

          # Clean up temp config
          rm -f .eslintrc-security.json

          # Process results
          if [ -f "security-results/eslint-security-results.json" ]; then
            ESLINT_FINDINGS=$(jq '[.[] | select(.errorCount > 0 or .warningCount > 0)] | length' security-results/eslint-security-results.json 2>/dev/null || echo "0")
            echo "üìã ESLint security scan found issues in $ESLINT_FINDINGS files"
            echo "eslint_findings=$ESLINT_FINDINGS" >> $GITHUB_OUTPUT

            if [ "$ESLINT_FINDINGS" -gt 0 ]; then
              echo "‚ö†Ô∏è ESLint security issues detected!"
              echo "has_issues=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ ESLint security scan completed successfully"
          fi

      # Free SAST with Bandit (for Python files if any)
      - name: "üîç Free Python SAST with Bandit"
        if: steps.scan-config.outputs.run_sast == 'true'
        continue-on-error: true
        run: |
          # Check if we have Python files
          if [ -z "$(find . -name "*.py" -not -path "./node_modules/*" -not -path "./.git/*" | head -1)" ]; then
            echo "No Python files found, skipping Bandit scan"
            exit 0
          fi

          echo "üìù Running Bandit security scan for Python files"
          pip install bandit

          # Run Bandit scan
          bandit -r . -f json -o security-results/bandit-results.json \
            --exclude "**/node_modules/**,**/.git/**,**/venv/**,**/__pycache__/**" || echo "Bandit scan completed"

          # Process results
          if [ -f "security-results/bandit-results.json" ]; then
            BANDIT_FINDINGS=$(jq '.results | length' security-results/bandit-results.json 2>/dev/null || echo "0")
            echo "üìã Bandit found $BANDIT_FINDINGS Python security issues"
            echo "bandit_findings=$BANDIT_FINDINGS" >> $GITHUB_OUTPUT

            if [ "$BANDIT_FINDINGS" -gt 0 ]; then
              echo "‚ö†Ô∏è Python security issues detected!"
              echo "has_issues=true" >> $GITHUB_OUTPUT
            fi
          fi

      # DAST Scanning with OWASP ZAP (only if URL provided)
      - name: "üåê DAST Scan with OWASP ZAP"
        if: steps.scan-config.outputs.run_dast == 'true' && inputs.target_url != ''
        continue-on-error: true
        run: |
          echo "üï∑Ô∏è Running OWASP ZAP baseline scan on ${{ inputs.target_url }}"
          mkdir -p security-results

          # Run ZAP baseline scan with timeout
          timeout 600 docker run --rm \
            -v $(pwd)/security-results:/zap/wrk/:rw \
            -u zap \
            ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
            -t "${{ inputs.target_url }}" \
            -J zap-report.json \
            -w zap-report.md \
            -r zap-report.html \
            -I \
            || echo "ZAP scan completed with warnings (exit code $?)"

          # Move results and check if scan produced output
          if [ -f "security-results/zap-report.json" ]; then
            echo "‚úÖ ZAP scan completed successfully"
            # Count alerts for summary
            ALERT_COUNT=$(jq '[.site[].alerts[]] | length' security-results/zap-report.json 2>/dev/null || echo "0")
            echo "üìä ZAP found $ALERT_COUNT security alerts"
            echo "zap_alerts=$ALERT_COUNT" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è ZAP scan did not produce results file"
            echo "zap_alerts=0" >> $GITHUB_OUTPUT
          fi

      # HTTP Security Headers Scan with securityheaders.com
      - name: "üõ°Ô∏è HTTP Security Headers Scan"
        if: inputs.target_url != ''
        continue-on-error: true
        run: |
          echo "üîç Checking security headers for ${{ inputs.target_url }}"
          mkdir -p security-results

          API_URL="https://securityheaders.com/?q=${{ inputs.target_url }}&hide=on&followRedirects=on&format=json"
          echo "Requesting $API_URL"
          RESPONSE=$(curl -s "$API_URL" || true)

          if [ -z "$RESPONSE" ]; then
            echo "‚ö†Ô∏è  Unable to fetch SecurityHeaders results"
            exit 0
          fi

          echo "$RESPONSE" > security-results/securityheaders.json

          GRADE=$(echo "$RESPONSE" | jq -r '.grade // empty')
          if [ -z "$GRADE" ]; then
            echo "‚ö†Ô∏è  Could not determine grade from response"
            exit 0
          fi

          echo "Security Headers grade: $GRADE"
          echo "securityheaders_grade=$GRADE" >> $GITHUB_OUTPUT

          case "$GRADE" in
            A+|A)
              echo "‚úÖ Acceptable security headers grade ($GRADE)"
              ;;
            *)
              echo "üö® SECURITY ALERT: Poor security headers grade ($GRADE)"
              echo "has_issues=true" >> $GITHUB_OUTPUT
              ;;
          esac

      # Enhanced Dependency Scanning
      - name: "üì¶ Dependency Vulnerability Scan"
        if: steps.scan-config.outputs.run_dependencies == 'true'
        continue-on-error: true
        run: |
          echo "üì¶ Running dependency vulnerability scan"

          # npm audit
          if [ -f "package.json" ]; then
            npm audit --audit-level=moderate --json > security-results/npm-audit.json || echo "npm audit completed"

            if [ -f "security-results/npm-audit.json" ]; then
              VULNERABILITIES=$(jq '.metadata.vulnerabilities.total // 0' security-results/npm-audit.json 2>/dev/null || echo "0")
              echo "üìã npm audit found $VULNERABILITIES total vulnerabilities"
              echo "npm_vulnerabilities=$VULNERABILITIES" >> $GITHUB_OUTPUT

              if [ "$VULNERABILITIES" -gt 0 ]; then
                echo "üö® SECURITY ALERT: Dependency vulnerabilities detected!"
                echo "has_issues=true" >> $GITHUB_OUTPUT
              fi
            fi
          fi

      # Enhanced Dependency Scanning with Snyk (if token available)
      - name: "üêç Enhanced Dependency Scan with Snyk"
        if: steps.scan-config.outputs.run_dependencies == 'true' && env.SNYK_TOKEN != ''
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        uses: snyk/actions/node@master
        with:
          args: --severity-threshold=${{ inputs.severity_threshold }} --sarif-file-output=security-results/snyk-results.sarif

      # Container Image Scanning with Trivy
      - name: "üê≥ Container Security Scan with Trivy"
        if: steps.scan-config.outputs.run_container == 'true'
        continue-on-error: true
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'security-results/trivy-results.sarif'

      # License Compliance Scanning
      - name: "üìÑ License Compliance Scan"
        if: steps.scan-config.outputs.run_license == 'true' && env.FOSSA_API_KEY != ''
        continue-on-error: true
        env:
          FOSSA_API_KEY: ${{ secrets.FOSSA_API_KEY }}
        uses: fossa-contrib/fossa-action@v3
        with:
          fossa-api-key: ${{ secrets.FOSSA_API_KEY }}

      # Infrastructure as Code (IaC) Security
      - name: "üèóÔ∏è IaC Security Scan with Checkov"
        if: steps.scan-config.outputs.run_iac == 'true'
        continue-on-error: true
        uses: bridgecrewio/checkov-action@master
        with:
          directory: .
          framework: terraform,cloudformation,kubernetes,dockerfile
          output_format: sarif
          output_file_path: security-results/checkov-results.sarif

      # Financial Services Compliance Check (Enhanced)
      - name: "üè¶ Financial Compliance Check"
        if: (steps.scan-config.outputs.run_financial == 'true' || inputs.include_financial_compliance) && steps.scan-config.outputs.run_financial != 'false'
        continue-on-error: true
        run: |
          echo "üè¶ Checking Financial Services Compliance for ${{ inputs.app_name }}..."

          # Check for payment-related code
          echo "üìã PCI DSS Configuration Check:"
          if find . -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" -o -name "*.json" | xargs grep -l "credit.*card\|payment\|billing\|stripe\|paypal" 2>/dev/null; then
            echo "‚ö†Ô∏è  Payment-related code detected - PCI DSS compliance may be required"
            echo "has_payment_code=true" >> $GITHUB_OUTPUT
          fi

          # Check for financial data handling
          echo "üìã Financial Data Handling Check:"
          if find . -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | xargs grep -l "ssn\|social.*security\|tax.*id\|ein\|routing.*number\|account.*number" 2>/dev/null; then
            echo "‚ö†Ô∏è  Financial data handling detected - Enhanced security required"
            echo "has_financial_data=true" >> $GITHUB_OUTPUT
          fi

          # Check for encryption and security measures
          echo "üìã Security Implementation Check:"
          ENCRYPTION_CHECK=$(find . -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | xargs grep -l "encrypt\|crypto\|bcrypt\|jwt" 2>/dev/null | wc -l)
          if [ "$ENCRYPTION_CHECK" -gt 0 ]; then
            echo "‚úÖ Encryption implementations found: $ENCRYPTION_CHECK files"
          else
            echo "‚ö†Ô∏è  No obvious encryption implementations found"
          fi

          # Tax software specific checks
          echo "üìã Tax Software Compliance Check:"
          if find . -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | xargs grep -l "irs\|tax.*return\|cfc\|pfic\|1040\|8865" 2>/dev/null; then
            echo "‚úÖ Tax software compliance context detected"
            echo "is_tax_software=true" >> $GITHUB_OUTPUT
          fi

      # Token Storage Security Check (from existing security scan)
      - name: "üîí Insecure Token Storage Detection"
        if: steps.scan-config.outputs.run_sast == 'true'
        continue-on-error: true
        run: |
          echo "üîí Checking for insecure token storage..."

          # Static analysis for insecure storage patterns
          INSECURE_PATTERNS_FOUND=false

          # Check for localStorage usage with tokens
          if find . -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | xargs grep -l "localStorage.*token\|localStorage.*auth\|localStorage.*jwt" 2>/dev/null; then
            echo "‚ö†Ô∏è  localStorage token storage detected"
            INSECURE_PATTERNS_FOUND=true
          fi

          # Check for sessionStorage with sensitive data
          if find . -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | xargs grep -l "sessionStorage.*token\|sessionStorage.*auth\|sessionStorage.*jwt" 2>/dev/null; then
            echo "‚ö†Ô∏è  sessionStorage token storage detected"
            INSECURE_PATTERNS_FOUND=true
          fi

          # Check for cookies without secure flags
          if find . -name "*.js" -o -name "*.ts" -o -name "*.tsx" -o -name "*.jsx" | xargs grep -l "document\.cookie.*token\|document\.cookie.*auth" 2>/dev/null; then
            echo "‚ö†Ô∏è  Potentially insecure cookie usage detected"
            INSECURE_PATTERNS_FOUND=true
          fi

          if [ "$INSECURE_PATTERNS_FOUND" = true ]; then
            echo "üö® SECURITY ALERT: Insecure token storage patterns detected!"
            echo "has_insecure_tokens=true" >> $GITHUB_OUTPUT
            echo "has_issues=true" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ No obvious insecure token storage patterns found"
          fi

      # Check for SARIF files and upload to GitHub Security
      - name: "üìä Check and Upload SARIF Results"
        id: sarif-upload
        if: always()
        continue-on-error: true
        run: |
          echo "üîç Checking for SARIF files to upload..."

          # List all potential SARIF files
          SARIF_FILES=""
          SARIF_COUNT=0

          if [ -f "security-results/trivy-results.sarif" ]; then
            echo "‚úÖ Found trivy-results.sarif"
            SARIF_FILES="$SARIF_FILES security-results/trivy-results.sarif"
            SARIF_COUNT=$((SARIF_COUNT + 1))
          else
            echo "‚ö†Ô∏è  trivy-results.sarif not found (expected from container scan)"
          fi

          if [ -f "security-results/checkov-results.sarif" ]; then
            echo "‚úÖ Found checkov-results.sarif"
            SARIF_FILES="$SARIF_FILES security-results/checkov-results.sarif"
            SARIF_COUNT=$((SARIF_COUNT + 1))
          else
            echo "‚ö†Ô∏è  checkov-results.sarif not found (expected from IaC scan)"
          fi

          # Check for any other SARIF files
          OTHER_SARIF=$(find security-results/ -name "*.sarif" 2>/dev/null | grep -v "trivy-results.sarif\|checkov-results.sarif" || true)
          if [ ! -z "$OTHER_SARIF" ]; then
            echo "‚úÖ Found additional SARIF files: $OTHER_SARIF"
            SARIF_FILES="$SARIF_FILES $OTHER_SARIF"
            SARIF_COUNT=$((SARIF_COUNT + $(echo "$OTHER_SARIF" | wc -l)))
          fi

          if [ "$SARIF_COUNT" -gt 0 ]; then
            echo "üì§ Found $SARIF_COUNT SARIF file(s) to upload"
            echo "sarif_files_found=true" >> $GITHUB_OUTPUT
            # Create a combined SARIF directory for upload
            mkdir -p security-results/sarif-upload
            for file in $SARIF_FILES; do
              if [ -f "$file" ]; then
                cp "$file" security-results/sarif-upload/
              fi
            done
            echo "sarif_upload_dir=security-results/sarif-upload" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è  No SARIF files found to upload"
            echo "sarif_files_found=false" >> $GITHUB_OUTPUT
          fi

      # Upload SARIF files to GitHub Security (requires GitHub Advanced Security)
      - name: "üì§ Upload SARIF to GitHub Security"
        id: sarif-upload-step
        if: always() && steps.sarif-upload.outputs.sarif_files_found == 'true'
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: ${{ steps.sarif-upload.outputs.sarif_upload_dir }}
          category: security-scan-results
        continue-on-error: true

      # Handle SARIF upload result and provide informative message
      - name: "üìã SARIF Upload Status"
        if: always() && steps.sarif-upload.outputs.sarif_files_found == 'true'
        run: |
          if [ "${{ steps.sarif-upload-step.outcome }}" = "failure" ]; then
            echo "‚ö†Ô∏è SARIF upload failed - This is expected if GitHub Advanced Security is not enabled"
            echo "‚ÑπÔ∏è SARIF files are still available in the workflow artifacts for manual review"
            echo "sarif_uploaded=false" >> $GITHUB_OUTPUT
          elif [ "${{ steps.sarif-upload-step.outcome }}" = "success" ]; then
            echo "‚úÖ SARIF files successfully uploaded to GitHub Security tab"
            echo "sarif_uploaded=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è SARIF upload skipped or not attempted"
            echo "sarif_uploaded=false" >> $GITHUB_OUTPUT
          fi

      # Upload security results
      - name: "üì§ Upload Security Results"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results-${{ inputs.app_name }}-${{ github.run_number }}
          path: security-results/
          retention-days: 30

      # Enhanced Security Summary and Notification
      - name: "üìä Create Security Summary and Notifications"
        if: always()
        run: |
          echo "## üõ°Ô∏è Security Scan Results for ${{ inputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Scan Overview" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: ${{ inputs.app_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Framework**: ${{ steps.framework.outputs.framework }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Scan Type**: ${{ inputs.scan_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Repository**: ${{ inputs.repository_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "- **Target URL**: ${{ inputs.target_url || 'N/A' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "### üîç Security Scan Results" >> $GITHUB_STEP_SUMMARY

          TOTAL_ISSUES=0
          CRITICAL_ISSUES=false

          # Secrets scan results
          if [ -f "security-results/gitleaks-report.json" ]; then
            SECRETS_COUNT=$(jq length security-results/gitleaks-report.json 2>/dev/null || echo "0")
            if [ "$SECRETS_COUNT" -eq 0 ]; then
              echo "- üü¢ **Secrets Scan**: No secrets detected" >> $GITHUB_STEP_SUMMARY
            else
              echo "- üî¥ **Secrets Scan**: $SECRETS_COUNT potential secrets found ‚ö†Ô∏è" >> $GITHUB_STEP_SUMMARY
              TOTAL_ISSUES=$((TOTAL_ISSUES + SECRETS_COUNT))
              CRITICAL_ISSUES=true
            fi
          else
            echo "- ‚ö™ **Secrets Scan**: Skipped or failed" >> $GITHUB_STEP_SUMMARY
          fi

          # SAST scan results (multiple tools)
          TOTAL_SAST_ISSUES=0
          SAST_TOOLS_RUN=0

          # Semgrep results (premium)
          if [ -f "security-results/semgrep-results.json" ]; then
            SEMGREP_COUNT=$(jq '.results | length' security-results/semgrep-results.json 2>/dev/null || echo "0")
            TOTAL_SAST_ISSUES=$((TOTAL_SAST_ISSUES + SEMGREP_COUNT))
            SAST_TOOLS_RUN=$((SAST_TOOLS_RUN + 1))
            echo "- üîç **Semgrep (Premium)**: $SEMGREP_COUNT findings" >> $GITHUB_STEP_SUMMARY
          fi

          # ESLint security results (free)
          if [ -f "security-results/eslint-security-results.json" ]; then
            ESLINT_COUNT=$(jq '[.[] | select(.errorCount > 0 or .warningCount > 0)] | length' security-results/eslint-security-results.json 2>/dev/null || echo "0")
            TOTAL_SAST_ISSUES=$((TOTAL_SAST_ISSUES + ESLINT_COUNT))
            SAST_TOOLS_RUN=$((SAST_TOOLS_RUN + 1))
            echo "- üîç **ESLint Security (Free)**: Issues in $ESLINT_COUNT files" >> $GITHUB_STEP_SUMMARY
          fi

          # Bandit results (free, for Python)
          if [ -f "security-results/bandit-results.json" ]; then
            BANDIT_COUNT=$(jq '.results | length' security-results/bandit-results.json 2>/dev/null || echo "0")
            TOTAL_SAST_ISSUES=$((TOTAL_SAST_ISSUES + BANDIT_COUNT))
            SAST_TOOLS_RUN=$((SAST_TOOLS_RUN + 1))
            echo "- üîç **Bandit Python (Free)**: $BANDIT_COUNT findings" >> $GITHUB_STEP_SUMMARY
          fi

          # Security Headers results
          if [ -f "security-results/securityheaders.json" ]; then
            SH_GRADE=$(jq -r '.grade' security-results/securityheaders.json 2>/dev/null || echo "")
            if [ -z "$SH_GRADE" ]; then
              echo "- ‚ö™ **Security Headers**: Failed to parse results" >> $GITHUB_STEP_SUMMARY
            else
              echo "- üîç **Security Headers**: Grade $SH_GRADE" >> $GITHUB_STEP_SUMMARY
              case "$SH_GRADE" in
                A+|A)
                  ;; # good grades, no action
                *)
                  TOTAL_ISSUES=$((TOTAL_ISSUES + 1))
                  CRITICAL_ISSUES=true
                  ;;
              esac
            fi
          else
            echo "- ‚ö™ **Security Headers**: Skipped or failed" >> $GITHUB_STEP_SUMMARY
          fi

          # DAST scan results (ZAP)
          if [ -f "security-results/zap-report.json" ]; then
            ZAP_ALERTS=$(jq '[.site[].alerts[]] | length' security-results/zap-report.json 2>/dev/null || echo "0")
            if [ "$ZAP_ALERTS" -eq 0 ]; then
              echo "- üü¢ **DAST Scan (ZAP)**: No security alerts found" >> $GITHUB_STEP_SUMMARY
            else
              echo "- üî¥ **DAST Scan (ZAP)**: $ZAP_ALERTS security alerts found ‚ö†Ô∏è" >> $GITHUB_STEP_SUMMARY
              TOTAL_ISSUES=$((TOTAL_ISSUES + ZAP_ALERTS))
            fi
          else
            echo "- ‚ö™ **DAST Scan (ZAP)**: Skipped or failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Overall SAST summary
          if [ "$SAST_TOOLS_RUN" -eq 0 ]; then
            echo "- ‚ö™ **SAST Scan**: No SAST tools ran" >> $GITHUB_STEP_SUMMARY
          elif [ "$TOTAL_SAST_ISSUES" -eq 0 ]; then
            echo "- üü¢ **SAST Summary**: No security issues detected ($SAST_TOOLS_RUN tools)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- üî¥ **SAST Summary**: $TOTAL_SAST_ISSUES total findings ($SAST_TOOLS_RUN tools) ‚ö†Ô∏è" >> $GITHUB_STEP_SUMMARY
            TOTAL_ISSUES=$((TOTAL_ISSUES + TOTAL_SAST_ISSUES))
          fi

          # Dependency scan results
          if [ -f "security-results/npm-audit.json" ]; then
            DEPS_COUNT=$(jq '.metadata.vulnerabilities.total // 0' security-results/npm-audit.json 2>/dev/null || echo "0")
            if [ "$DEPS_COUNT" -eq 0 ]; then
              echo "- üü¢ **Dependency Scan**: No vulnerabilities found" >> $GITHUB_STEP_SUMMARY
            else
              echo "- üî¥ **Dependency Scan**: $DEPS_COUNT vulnerabilities found ‚ö†Ô∏è" >> $GITHUB_STEP_SUMMARY
              TOTAL_ISSUES=$((TOTAL_ISSUES + DEPS_COUNT))
            fi
          else
            echo "- ‚ö™ **Dependency Scan**: Skipped or failed" >> $GITHUB_STEP_SUMMARY
          fi

          # Summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Overall Results" >> $GITHUB_STEP_SUMMARY
          if [ "$TOTAL_ISSUES" -eq 0 ]; then
            echo "- ‚úÖ **Status**: No security issues detected" >> $GITHUB_STEP_SUMMARY
            echo "- üéØ **Total Issues**: 0" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚ö†Ô∏è **Status**: Security issues detected - Review required" >> $GITHUB_STEP_SUMMARY
            echo "- üéØ **Total Issues**: $TOTAL_ISSUES" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìÅ Detailed Results" >> $GITHUB_STEP_SUMMARY
          echo "- Download the **security-scan-results-${{ inputs.app_name }}-${{ github.run_number }}** artifact for detailed reports" >> $GITHUB_STEP_SUMMARY

          # Check if SARIF upload was successful
          if [ "${{ steps.sarif-upload.outputs.sarif_files_found }}" = "true" ]; then
            if [ "${{ steps.sarif-upload-step.outcome }}" = "success" ]; then
              echo "- ‚úÖ **Security Tab**: SARIF results uploaded to GitHub Security tab" >> $GITHUB_STEP_SUMMARY
            else
              echo "- ‚ö†Ô∏è **Security Tab**: SARIF upload failed (GitHub Advanced Security may not be enabled)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "- ‚ö™ **Security Tab**: No SARIF files generated (tools may not have found issues)" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚ÑπÔ∏è Additional Information" >> $GITHUB_STEP_SUMMARY
          echo "- **GitHub Advanced Security**: If you see 'Code Security must be enabled' warnings, this is normal for repositories without GitHub Advanced Security" >> $GITHUB_STEP_SUMMARY
          echo "- **SARIF Upload**: SARIF files are only uploaded when security tools generate findings" >> $GITHUB_STEP_SUMMARY
          echo "- **Free Alternatives**: This workflow uses free tools (ESLint Security, Bandit, npm audit) when premium tools aren't available" >> $GITHUB_STEP_SUMMARY

          # Send email notification if critical issues found
          if [ "$CRITICAL_ISSUES" = true ] && [ -n "${{ inputs.notification_email }}" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìß Notifications" >> $GITHUB_STEP_SUMMARY
            echo "- üö® Security team notified at ${{ inputs.notification_email }}" >> $GITHUB_STEP_SUMMARY
          fi

          # Set outputs for potential further processing
          echo "total_issues=$TOTAL_ISSUES" >> $GITHUB_OUTPUT
          echo "has_critical_issues=$CRITICAL_ISSUES" >> $GITHUB_OUTPUT

      # Central SOC2 Compliance Reporting
      - name: "üìä Send Results to SOC2 Dashboard"
        if: always()
        continue-on-error: true
        run: |
          echo "üìä Preparing security scan results for SOC2 compliance dashboard..."

          # Create consolidated security report
          cat > security-results/soc2-compliance-report.json << EOF
          {
            "scan_metadata": {
              "timestamp": "$(date -u '+%Y-%m-%dT%H:%M:%SZ')",
              "repository": "${{ inputs.repository_name }}",
              "application": "${{ inputs.app_name }}",
              "branch": "${{ github.ref_name }}",
              "commit_sha": "${{ github.sha }}",
              "scan_type": "${{ inputs.scan_type }}",
              "workflow_run_id": "${{ github.run_id }}",
              "workflow_run_number": "${{ github.run_number }}"
            },
            "compliance_status": {
              "overall_status": "$(if [ "${{ steps.security-scan.outputs.has_critical_issues || 'false' }}" = "true" ]; then echo "NON_COMPLIANT"; else echo "COMPLIANT"; fi)",
              "total_issues": ${{ steps.security-scan.outputs.total_issues || 0 }},
              "severity_threshold": "${{ inputs.severity_threshold }}",
              "financial_compliance_enabled": ${{ inputs.include_financial_compliance }},
              "scan_coverage": {
                "secrets_scanning": $(if [ "${{ steps.scan-config.outputs.run_secrets }}" = "true" ]; then echo "true"; else echo "false"; fi),
                "sast_scanning": $(if [ "${{ steps.scan-config.outputs.run_sast }}" = "true" ]; then echo "true"; else echo "false"; fi),
                "dependency_scanning": $(if [ "${{ steps.scan-config.outputs.run_dependencies }}" = "true" ]; then echo "true"; else echo "false"; fi),
                "container_scanning": $(if [ "${{ steps.scan-config.outputs.run_container }}" = "true" ]; then echo "true"; else echo "false"; fi),
                "dast_scanning": $(if [ "${{ steps.scan-config.outputs.run_dast }}" = "true" ]; then echo "true"; else echo "false"; fi)
              }
            },
            "scan_results": {
              "secrets": {
                "tool": "gitleaks",
                "findings": ${{ steps.secrets-scan.outputs.secrets_found || 0 }},
                "status": "$(if [ -f "security-results/gitleaks-report.json" ]; then echo "completed"; else echo "fallback_used"; fi)"
              },
              "sast": {
                "tools_used": ["semgrep", "eslint-security", "bandit"],
                "semgrep_findings": ${{ steps.sast-scan.outputs.semgrep_findings || 0 }},
                "eslint_findings": ${{ steps.sast-scan.outputs.eslint_findings || 0 }},
                "bandit_findings": ${{ steps.sast-scan.outputs.bandit_findings || 0 }}
              },
              "dependencies": {
                "tool": "npm-audit",
                "vulnerabilities": ${{ steps.dependency-scan.outputs.npm_vulnerabilities || 0 }},
                "snyk_available": $(if [ -n "${{ secrets.SNYK_TOKEN }}" ]; then echo "true"; else echo "false"; fi)
              },
              "web_security": {
                "security_headers_grade": "${{ steps.headers-scan.outputs.securityheaders_grade || 'not_tested' }}",
                "zap_alerts": ${{ steps.dast-scan.outputs.zap_alerts || 0 }}
              }
            },
            "evidence_artifacts": {
              "sarif_uploaded": ${{ steps.sarif-upload.outputs.sarif_uploaded || 'false' }},
              "artifacts_available": true,
              "artifact_name": "security-scan-results-${{ inputs.app_name }}-${{ github.run_number }}",
              "retention_days": 30
            }
          }
          EOF

          echo "‚úÖ SOC2 compliance report generated: security-results/soc2-compliance-report.json"

          # Send to central compliance database/API (examples)

          # Option 1: Send to custom SOC2 API endpoint
          if [ -n "${{ secrets.SOC2_COMPLIANCE_API_URL }}" ] && [ -n "${{ secrets.SOC2_API_KEY }}" ]; then
            echo "üì§ Sending results to SOC2 compliance API..."
            curl -X POST "${{ secrets.SOC2_COMPLIANCE_API_URL }}/security-scans" \
              -H "Authorization: Bearer ${{ secrets.SOC2_API_KEY }}" \
              -H "Content-Type: application/json" \
              -d @security-results/soc2-compliance-report.json \
              || echo "‚ö†Ô∏è Failed to send to SOC2 API"
          fi

          # Option 2: Send to Slack/Teams for immediate notification
          if [ -n "${{ secrets.SOC2_SLACK_WEBHOOK }}" ] && [ "${{ steps.security-scan.outputs.has_critical_issues || 'false' }}" = "true" ]; then
            echo "üö® Sending SOC2 compliance alert to Slack..."
            curl -X POST "${{ secrets.SOC2_SLACK_WEBHOOK }}" \
              -H "Content-Type: application/json" \
              -d '{
                "text": "üö® SOC2 Security Compliance Alert",
                "blocks": [
                  {
                    "type": "section",
                    "text": {
                      "type": "mrkdwn",
                      "text": "*SOC2 Security Compliance Alert*\n\n*Application:* ${{ inputs.app_name }}\n*Repository:* ${{ inputs.repository_name }}\n*Status:* ‚ö†Ô∏è NON-COMPLIANT\n*Issues Found:* ${{ steps.security-scan.outputs.total_issues || 0 }}\n*Scan Time:* $(date -u)"
                    }
                  },
                  {
                    "type": "actions",
                    "elements": [
                      {
                        "type": "button",
                        "text": {
                          "type": "plain_text",
                          "text": "View Results"
                        },
                        "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                      }
                    ]
                  }
                ]
              }' || echo "‚ö†Ô∏è Failed to send Slack notification"
          fi

          # Option 3: Create GitHub Issue for tracking (SOC2 audit trail)
          if [ "${{ steps.security-scan.outputs.has_critical_issues || 'false' }}" = "true" ] && [ -n "${{ secrets.GITHUB_TOKEN }}" ]; then
            echo "üìã Creating SOC2 compliance tracking issue..."

            # Create issue body
            cat > issue-body.md << 'ISSUE_EOF'
          ## üö® SOC2 Security Compliance Issue

          **Scan Details:**
          - **Application:** ${{ inputs.app_name }}
          - **Repository:** ${{ inputs.repository_name }}
          - **Scan Time:** $(date -u)
          - **Workflow Run:** [${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - **Commit:** ${{ github.sha }}

          **Compliance Status:** ‚ö†Ô∏è NON-COMPLIANT

          **Issues Summary:**
          - **Total Issues:** ${{ steps.security-scan.outputs.total_issues || 0 }}
          - **Critical Issues:** Yes
          - **Severity Threshold:** ${{ inputs.severity_threshold }}

          **SOC2 Controls Affected:**
          - CC6.1 - Logical and Physical Access Controls
          - CC6.6 - Protection Against Vulnerabilities
          - CC7.1 - System Monitoring

          **Required Actions:**
          1. [ ] Review security scan results
          2. [ ] Remediate critical security issues
          3. [ ] Re-run security scan to verify fixes
          4. [ ] Update SOC2 compliance documentation

          **Evidence:**
          - Security scan artifacts: Available for 30 days
          - SARIF files: $(if [ "${{ steps.sarif-upload.outputs.sarif_uploaded }}" = "true" ]; then echo "Uploaded to GitHub Security"; else echo "Available in artifacts"; fi)

          ---
          *This issue was automatically created for SOC2 compliance tracking.*
          ISSUE_EOF

            # Create the issue using GitHub CLI or API
            if command -v gh >/dev/null 2>&1; then
              gh issue create \
                --title "SOC2 Security Compliance Issue - ${{ inputs.app_name }} - $(date +'%Y-%m-%d')" \
                --body-file issue-body.md \
                --label "security,soc2-compliance,high-priority" \
                --assignee "${{ github.actor }}" \
                || echo "‚ö†Ô∏è Failed to create compliance tracking issue"
            fi

            rm -f issue-body.md
          fi

          # Option 4: Send to Elasticsearch/Splunk for centralized logging
          if [ -n "${{ secrets.ELASTICSEARCH_URL }}" ] && [ -n "${{ secrets.ELASTICSEARCH_API_KEY }}" ]; then
            echo "üìä Sending results to Elasticsearch for SOC2 dashboard..."
            curl -X POST "${{ secrets.ELASTICSEARCH_URL }}/soc2-security-scans/_doc" \
              -H "Authorization: ApiKey ${{ secrets.ELASTICSEARCH_API_KEY }}" \
              -H "Content-Type: application/json" \
              -d @security-results/soc2-compliance-report.json \
              || echo "‚ö†Ô∏è Failed to send to Elasticsearch"
          fi

          echo "üìä SOC2 compliance reporting completed"
